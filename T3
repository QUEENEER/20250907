#include <bits/stdc++.h>
using namespace std;

int main(){
	int a,b;
	int c=0;
	cin>>a>>b;
	for(int i=1;i<a;i++){
		for(int j=i;j<a;j++){
			for(int k=j;k<a;k++){
				if(i+j+k==a){
					c+=1;
				}
			}
		}
	}
	cout<<c;
	return 0;
}
//第一次瞎做
#include <iostream>
using namespace std;

int main() {
	int n, k;
	cin >> n >> k;
	
	// dp[i][j] 表示将整数i分成j份的方案数
	int dp[201][7] = {0};
	
	// 初始化：将i分成1份只有1种方案
	for (int i = 1; i <= n; i++) {
		dp[i][1] = 1;
	}
	
	for (int i = 2; i <= n; i++) {
		for (int j = 2; j <= k; j++) {
			if (i >= j) {
				// 两种情况：
				// 1. 至少有一份是1：相当于将i-1分成j-1份
				// 2. 所有份都大于1：相当于将i-j分成j份（每份减1）
				dp[i][j] = dp[i-1][j-1] + dp[i-j][j];
			}
		}
	}
	
	cout << dp[n][k] << endl;
	return 0;
}
//deepseek给出的解法,使用递归,dp;
#include <iostream>
using namespace std;

int main() {
	int a,b;
	cin>>a>>b;
	int dp[201][7]={0};
	for(int i=1;i<=a;i++){
		dp[i][1]=1;
	}
	for(int i=2;i<=a;i++){
		for(int j=2;j<=b;j++){
			if(i>=j){
				dp[i][j]=dp[i-1][j-1]+dp[i-j][j];
			}
		}
	}
	cout<<dp[a][b]<<endl;
	return 0;
}
